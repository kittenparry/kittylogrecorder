#!/usr/bin/env python3

import tkinter as tk
from tkinter import messagebox
import time
import platform
import os
import sys
import signal
import argparse


def signal_handler(signal, frame):
	print(strings('msg_key_interrupt'))
	sys.exit()

signal.signal(signal.SIGINT, signal_handler)

VERSION = '1.4.1'

# colourful messages
class COL:
	FAIL = '\033[91m'
	WARNING = '\033[93m'
	UNDERLINE = '\033[4m'
	BOLD = '\033[1m'
	ENDC = '\033[0m'
	if platform.system() == 'Windows':
		FAIL = ''
		WARNING = ''
		UNDERLINE = ''
		BOLD = ''
		ENDC = ''


class Gui(tk.Frame):

	def __init__(self, master = None):
		tk.Frame.__init__(self, master)
		self.row_top = tk.Frame(master)
		self.row_bot = tk.Frame(master)
		self.row_top.grid(row=0, column=0)
		self.row_bot.grid(row=1, column=0, sticky='ew', padx=(10,0))
		self.add_elements()
		self.set_time()

	# draw/create gui elements
	def add_elements(self):
		# text area input and y-scrollbar
		# bind RETURN to text area input
		self.text_entry = tk.Text(self.row_bot, width=50, height=4, wrap='word', undo=True)
		self.text_entry.bind('<Return>', self.log_entry_event)
		self.text_entry.bind('<KP_Enter>', self.log_entry_event)
		self.scrolly = tk.Scrollbar(self.row_bot, orient='vertical', command=self.text_entry.yview)
		self.text_entry.configure(yscrollcommand=self.scrolly.set)

		# enter button
		self.button_enter = tk.Button(self.row_top, text=strings('button_enter'), command=self.log_entry)

		# time labels
		self.label_time = tk.Label(self.row_top, text='')

		# pack time, message, text area input and enter button
		# don't pack directory and filename label/entries
		# pack y-scrollbar separately
		self.elements = [self.label_time, self.text_entry, self.button_enter]
		for el in self.elements:
			el.pack(side='left', pady=2, padx=1)
		self.scrolly.pack(side='left', fill='y')

		# focus text area input on launch
		self.text_entry.focus()

	# entry event bound to RETURN key press on text area input
	# return 'break' prevents the logging of a new line character born from RETURN key press
	def log_entry_event(self, event):
		self.log_entry()
		return 'break'

	# logging/appending to file function
	def log_entry(self):
		log_record(str(self.text_entry.get('1.0', 'end')), True)
		self.text_entry.delete('1.0', 'end')

	# reset gui date/time display every .3 seconds
	def set_time(self):
		self.label_time.config(text=get_time())
		self.after(333, self.set_time)


# a dictionary of strings to hold everything in one place
dict_strings = {
	# static
	'title': 'Log Recorder',
	'button_enter': 'Enter',
	'version': '1.3.4',
	'version_full': 'logrecorder version %s',
	'path_config': os.path.join(os.path.expanduser('~'), '.config', 'logrecorder'),
	'name_config': 'config.logrecorder',
	###
	'help': """Usage: logrecorder [OPTIONS]
	
Options:
  -p, --path PATH\tSet & save destination directory to the config file.
  -f, --file FILENAME\tSet & save target filename to the config file.
\t\t\t  Creating the config file will override path values of in-program dictionary (dict_strings: path_dir, name_filename).
  -d, --del\t\tDelete the configuration file & folder.
  -c, --cli\t\tLaunch the program in CLI instead of GUI in Windows.
  -g, --gui\t\tLaunch the program in GUI instead of CLI.
\t\t\t  When combining with path options, GUI must come last.
  -v, --version\t\tShow version information and exit.
  -h, --help\t\tShow this message and exit.""",
	###
	# messages
	'title_dir_create': 'Directory Created',
	'msg_dir_create': 'Directory %s has been created.',
	'title_err_io': 'I/O Error',
	'invalid_option': 'Invalid option \'%s\'.\nTry --help for help.',
	'invalid_num_args': 'Invalid number of arguments.\nTry --help for help.',
	'msg_key_interrupt': '\nProgram was shutdown by user input (CTRL-C).',
	'msg_def_conf_create': 'Default config file has been created.',
	'msg_path_set': '%s has been set to %s.\nFull path is %s',
	'msg_del_sure': 'Are you sure you want to delete the configuration file? (y/n) ',
	'msg_del_canc': 'Configuration file deletion is cancelled by user.',
	'invalid_yn': 'Invalid input. Only enter y or n.',
	'msg_del_succ': 'Configuration file & folder has been deleted.',
	'msg_conf_exs': 'Configuration file already does not exist.',
	# configurable
	'path_dir': 'Other',
	'name_filename': 'myLogs',
}

# returns the string value with given key
def strings(s):
	return dict_strings.get(s)

# if on Windows spawns the window to the upper left of the screen
# else top of the middle
# note: I don't have access to OS X to see if it looks good or if it works
# FIXME: assumes 1920 screen width for other OSes
def get_geometry():
	if platform.system() == 'Windows':
		return '435x115+94+0'
	# elif os == 'Linux'
	# might as well use else to include OS X
	else:
		screen_width = 1920
		program_width = 390
		x_position = (screen_width - program_width) / 2
		return ('%dx115+%d+30' % (program_width, x_position))

def log_record(entry, gui = False):
	try:
		# get path and filename from their respective entries
		# currently the static values in the strings dictionary
		data = get_config()
		path = data[0]
		file = data[1]
		# create the directory if it doesn't exist already and inform the user
		if not os.path.exists(path):
			os.makedirs(path)
			if gui:
				messagebox.showinfo(strings('title_dir_create'), strings('msg_dir_create') % path)
			# print information message to console no matter
			print(strings('msg_dir_create') % path)
		
		# if filename doesn't end in .txt append it
		# join path & filename
		file = get_txt_ext(file)
		log_path = os.path.join(path, file)
		
		# format the log output
		# 2019.03.07 20:30:05| this is a test log.
		# append it to the log file and clear the text area input
		log = get_time() + '| ' + str(entry).strip() + ('' if gui else '\n')
		with open(log_path, 'a') as f:
			f.write(log)
	except IOError as e:
		if gui:
			messagebox.showerror(strings('title_err_io'), str(e))
		# print error log to console no matter
		print("%s: %s" % (strings('title_err_io'), str(e)))

# get time in the most logical fashion ever invented by mankind
# ISO-8601 https://www.iso.org/iso-8601-date-and-time-format.html
# YYYY.MM.DD HH:MM:SS ex. 2019.03.07 20:30:05
# month, day, hour, minute and seconds are with leading zeroes
# 24 hour formatting to not lose much more space in time
def get_time():
	return time.strftime('%Y.%m.%d %H:%M:%S')

# get path values if config file exists, else get them from the dictionary
def get_config():
	try:
		name_config = os.path.join(strings('path_config'), strings('name_config'))
		if os.path.isfile(name_config):
			with open(name_config, 'r') as config:
				data = config.readlines()
				data[0] = data[0].rstrip()
				return data
		else:
			return [strings('path_dir'), strings('name_filename')]

	except IOError as e:
		print("%s: %s" % (strings('title_err_io'), str(e)))

# set path values with CLI options
def set_config(key, value):
	name_config = os.path.join(strings('path_config'), strings('name_config'))
	try:
		if not os.path.isdir(strings('path_config')):
			os.makedirs(strings('path_config'))
		if not os.path.isfile(name_config):
			with open(name_config, 'w') as config:
				def_data = '%s\n%s' % (strings('path_dir'), strings('name_filename'))
				config.writelines(def_data)
			print(strings('msg_def_conf_create'))

		with open(name_config, 'r') as config:
			data = config.readlines()

		if key == 'Path':
			file_name = get_txt_ext(data[1])
			full_path = os.path.join(value, file_name)
			data[0] = value + '\n'
		else: # Filename
			file_name = get_txt_ext(value)
			full_path = os.path.join(data[0].rstrip(), file_name)
			data[1] = value

		with open(name_config, 'w') as config:
			config.writelines(data)
		print(strings('msg_path_set') % (key, value, full_path))

	except IOError as e:
		print("%s: %s" % (strings('title_err_io'), str(e)))

def del_config():
	name_config = os.path.join(strings('path_config'), strings('name_config'))
	if os.path.isfile(name_config):
		while True:
			reply = input(strings('msg_del_sure'))
			reply = reply.lower()
			if reply == 'y' or reply == 'yes':
				break
			elif reply == 'n' or reply == 'no':
				print(strings('msg_del_canc'))
				sys.exit()
			else:
				print(strings('invalid_yn'))
		try:
			os.unlink(name_config)
			os.rmdir(strings('path_config'))
			print(strings('msg_del_succ'))
		except IOError as e:
			print("%s: %s" % (strings('title_err_io'), str(e)))
	else:
		print(strings('msg_conf_exs'))

def get_txt_ext(file):
	return (file + '.txt') if file[len(file)-4:len(file)] != '.txt' else file


def start_cli():
	print(strings('title'))
	# TODO: print info on how to close (ctrl-c) and how to clear if possible
	while True:
		entry = input('>>')
		log_record(entry)

def start_gui():
	root = tk.Tk(className='logrecorder')
	# dpi problem fix for my own self, might not be an issue elsewhere
	if platform.system() == 'Linux':
		root.tk.call('tk', 'scaling', 1.3)
	root.title(strings('title'))
	root.geometry(get_geometry())
	app = Gui(master=root)
	app.mainloop()


def start():
	parser = argparse.ArgumentParser(description='Write into a designated text file with timestamps. A diary, log keeping program if you will.')
	parser.add_argument('-v', '--version',
		help='show version information and exit',
		action='store_true')
	parser.add_argument('-i', '--info',
		help='print current path to log file and exit',
		action='store_true')
	parser.add_argument('-c', '--cli',
		help='launch the program in cli instead of gui (default behaviour in windows)',
		action='store_true')
	parser.add_argument('-g', '--gui',
		help='launch the program in gui instead of cli',
		action='store_true')
	parser.add_argument('-p', '--path',
		help='set path to log file in config file',
		type=str)

	args = parser.parse_args()
	if len(sys.argv) == 1:
		start_cli()
	else:
		if args.version:
			print('logrecorder version %s' % VERSION)
			sys.exit()
		if args.info:
			print('here be print to current log path')
			sys.exit()
		if args.path:
			print('log file path edit in config')
		if args.cli and args.gui:
			# TODO: warning or error message colours
			print('cannot combine --gui & --cli. defaulting to cli...')
			start_cli()
		elif args.cli: # cli or gui, not both
			start_cli()
		elif args.gui:
			start_gui()


if __name__ == '__main__':
	# on Windows with no argument provided, start with GUI by default
	if platform.system() == 'Windows' and len(sys.argv) == 1:
		sys.argv.append('-g')
	start()
